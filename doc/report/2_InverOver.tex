%% BREAK LINES EVERY 80 CHARACTERS TO HELP GIT WITH MERGING
The inver-over operator can be regarded as either a crossover or mutation 
operator because it takes information from other individuals in the GA's
mating pool, yet bases a single offspring off of a single primary parent, much 
the same way a mutation operator is unary, performing mutation on a single
individual \cite{p44}. Throughout this report, the inver-over operator will 
be referenced as a crossover operator as this was the inver-over 
algorithm's purpose in the GA developed.

\subsection{Usefulness}
As {\em inver-over} embodies aspects of both crossover and mutation 
operators, the operator  is designed to provide middle-ground to 
algorithms relying primarily on crossover for variation (as this is 
computationally expensive) and those relying on mutation for variety,
since this is often ineffective in escaping local minima%
\footnote{Local minima occur when the natural selection in the GA 
	narrows the gene pool towards an ostensibly optimal solution and 
	eliminates individuals that otherwise would evolve to become the 
	true optimal solution.} \cite{p44}.


\subsection{Representation}
A set $P$ of individuals of length $n$, each represented as a sequence
$i_k = \langle C_{c_k(0)}, C_{c_k(1)}, C_{c_k(2)}, \ldots, C_{c_k(n-1)} \rangle$,
where $c_k\colon \{0, 1, \ldots, n-1\} \to \{ 1, 2, \ldots, n \}$ is a bijection 
between indices of $i_k$, $0 \leqslant k < \card(P)$, and city indices as 
provided in the data file, is used to denote the population. Let 
$M \subsetneq P$ be the mating pool containing individuals 
$i_{m(0)}, i_{m(1)},\ldots, i_{m(\card(M)-1)}$ with $m\colon 
\{0, \ldots, \card(M)-1\} \to \{0, \ldots, \card(P) -1\}$
 an injective function mapping individuals in the mating pool $M$ to 
their equal `self' in the population $P$.

Fitness of an individual $i_k$, denoted by $\fit(i_k)$ in the Algorithm~\ref{alg:inver-over}, is then determined by the formula in 
\eqref{eq:fit1}.
\begin{equation}
\fit(i_m) = \sum_{j=0}^{n-1} \left\lVert \overrightarrow{C_j \, C_{j+1}} \right\rVert\text{,} \label{eq:fit1} 
\end{equation}
where 
\begin{equation*}
\left\lVert \overrightarrow{C_j \, C_{j+1}} \right\rVert = \sqrt{(x_{C_{j+1}} - x_{C_j})^2 + (y_{C_{j+1}} - y_{C_j})^2}
\end{equation*}
is the Eucliean distance between cities $C_j$ and $C_{j+1}$.\footnote{
	Take indices $j$ modulo $n$ so when $j=n-1$, $(n-1)+1  \equiv 0 \pmod n$
	 and we compute the distance from the last city back to the first.} Hence
a lower fitness score is better.

\subsection{Algorithm}
The algorithm (Algorithm~\ref{alg:inver-over}) used mirrors that 
depicted in the article by Tao and Michalewicz \cite{p44}.

\begin{algorithm}[H]
	\caption{The inver-over operator}\label{alg:inver-over}
	\small
	\begin{algorithmic}[1]
		\Require
		\Statex{$\triangleright$ $M$ be the mating pool}
		\Statex{$\triangleright$ \parbox[t]{0.9\linewidth}{$0 \leqslant i < \card(M)$ be the index of the initial parent}}
		\Statex{$\triangleright$ $n$ be the number of cities in the tour}
		\Ensure
		\Statex{$\triangleright$ New offspring individual created}
		\Statex
		\State{\textbf{var} $child := M[i]$} \Comment{Copy the parent}
		\State{\textbf{var} $unused := \{x \in \mathbb Z \mid 0 \leqslant x < n-1\}$} 
		\State{\textbf{var} $p := \frac{1}{2}$} 
		\State{\textbf{var} $c := \rand(unused)$} \Comment{Select randomly}
		\State{$unused  := unused\,\backslash\{c\}$}
		\While{$\card(unused) > 0$}
		\If{$\rand\{x \in \mathbb R \mid 0 \leqslant x < 1\} < p$}
		\State{$c' := \rand(unused)$}
		\Else
		\State{$newPar := \rand(M)$} 
		\State{$newParC := \where(newPar = child[c])$}
		\Statex \Comment{Index $j$ in $newPar$}
		\State{$c' := newParentC + 1$}
		\EndIf
		\State{$unused := unused\,\backslash\{c'\}$}
		\If{$child[c\pm1] = child[c']$}
		\State{\textbf{break} from the \textbf{while} loop}
		\EndIf
		\State{$child[c:c'] := child[c':c]$} \Comment{Invert}
		\State{$c := c'$}
		\EndWhile
		\If{$\fit(child) \geqslant \fit(M[i])$}
		\State{\textbf{return} $child$}
		\Else 
		\State{\textbf{return} $M[i]$}
		\EndIf 
	\end{algorithmic}
\end{algorithm}

Here $M[i]$ is the primary parent from which the child is based. 
One can observe that all changes are then made to this individual, 
like a mutation, yet they involve other individuals, denoted $newPar$,
 in the mating pool.

We borrow the following example of a single iteration of the algorithm 
from Tao and Michalewicz.
\begin{enumerate}
	\item Let $child = \langle 2, 3, 9, 4, 1, 5, 8, 6, 7\rangle$ and the current
	city index $c$ is $1$ so $child[c] = 3$.
	\item \begin{enumerate}
		\item Suppose the random number generated by 
		 $\rand\{x \in \mathbb R \mid 0 \leqslant x < 1\}$
		 does not exceed $p$. Another city index $c'$ from the child is 
		 selected, say $c' = 6$ so $child[c'] = 8$. The section of $child$ 
		 after indices $c$ and $c'$ (\ie $\langle 9, 4, 1, 5, 8 \rangle$) is 
		 inverted, leaving $child = \langle 2, 3, 8, 5, 1, 4, 9, 6, 7 \rangle$.
		\item Otherwise, another individual is (randomly) selected from the
		mating pool to become the new parent. Let this be 
		$\langle 1, 6, 4, 3, 5, 7, 9, 2, 8 \rangle$. Here the city next to 
		$child[c] = 3$ is city $5$. So, the segment of $child$ to invert is 
		that which starts after city 3 and terminates after city 5 
		(\ie $\langle 9, 4, 1, 5 \rangle$). This 
		leaves $child = \langle 2, 3, 5, 1, 4, 9, 8, 6, 7\rangle$.
	\end{enumerate}
\end{enumerate}
As in Tao and Michalewicz, we remark that in either case the resulting 
string is intermediate in the sense that the above inversion operator is 
applied several times before an offspring is evaluated. After a number
of iterations, suppose $child = \langle 9, 3, 6, 8, 5, 1, 4, 2, 7\rangle$ 
and $c = 2$ so $child[c] = 6$.
\begin{enumerate}
	\setcounter{enumi}{2}
	\item \begin{enumerate}
		\item  If $\rand\{x \in \mathbb R \mid 0 \leqslant x < 1\}$ is greater
		than $p$, the city following $child[c] = 6$ is selected from a 
		randomly chosen individual in the mating pool $M$. Let this 
		city be city $8$. As $8$ follows $6$ in $child$, the algorithm 
		terminates.
		\item Otherwise, a randomly selected city is chosen. This may 
		also be $8$, in which case the algorithm also terminates. If it is 
		not $8$, the algorithm continues as described in (2).
	\end{enumerate}
\end{enumerate} 